---
layout: post
comments: false
title:  "Optical Flow Estimation"
excerpt: "We use the Horn-Schunck method to estimate optical flow in a coarse-to-fine way. Implemented  in Python with subtle sparse matrix manipulations."
date:   2016-03-18 12:00:00
mathjax: true
---

Motion estimation among a sequence of images is a widely used task in computer vision, such as image
segmentation, object classification, and driver assistance.
In this community, researchers use ‘optical flow’ to describe the motion field. ‘Optical flow’ is a dense
vector field, where a 2D displacement vector is calculated for each pixel. The displacement vector points to its corresponding pixel from another image.

Since much of the structural information of a 3D scene gets lost in the imaging process, so does the motion information. The estimation of the accurate 2D motion in an image sequence is therefore ill-posed and has to be aided by additional priors, such as the smoothness property of motion.

> The main gotcha for me in this project is the matrix type convert to its sparse counterpart and use the scipy.sparse library, which took a long time to debug.

Unfortunately this project was done in a rush and most of the following parts are just roughly covered. Much more technical details (probably) will be addressed after the deadline or I am free from saving the world. :) The preliminary results and code are ready, however.

* [Results](https://www.dropbox.com/s/9wpnusqqwbypbrf/results.zip?dl=0)
* [Code](https://www.dropbox.com/s/igsxdam7seqxyz6/pano_code.zip?dl=0)

### Radial Distortion Correction
Involved rountines: <br/>
```WarpRDField``` in ```WarpSpherical.cpp```.

### Feature Extraction using SIFT
Third-party software to extract SIFT features directly out of ```.pgm``` images.

### Global Alignment
This is the most hacky part. Basically it contains __global alignment__ between any two images among the candidates and __bundle adjustment__ to deal with drift problem.

Involved rountines: <br/>
```alignImagePair, countInliers, leastSquaresFit``` in ```FeatureAlign.cpp```. <br/>
```initGlobalAlign, bundleAdjust``` in ```GlobalAlign.cpp```.

**Extra credit:** <br/>

* ```MatchFeatures``` in ```GlobalAlign.cpp```. I set a threshold (=0.5) to ensure that the best match (smallest distance) should be smaller than the second best one, otherwise, set ```feat_match.id = -1```.
* Bundle adjustment as instructed in the project page.


### Evaluation
Involved rountines: <br/>
```WarpSphericalField``` in ```WarpSpherical.cpp```. <br/>
```SetImageAlpha, AccumulateBlend, NormalizeBlend``` in ```BlendImages.cpp```.

### Ablation Study
There are mainly two factors could result in the final performance, where I tried several choices and find


<div class="imgcap">
<img src="/assets/pano/results/mountain.png">
<div class="thecap" style="text-align:justify">The mountain. We can see the separate images are well aligned and blended.  <a href="http://hli2020.github.io/assets/pano/pano_view/mountain.html">360-degree view</a>.</div>
</div>

<div class="imgcap">
<img src="/assets/pano/results/home.png">
<div class="thecap" style="text-align:justify">Panorama collected by myself. <a href="http://hli2020.github.io/assets/pano/pano_view/home.html">360-degree view</a>.</div>
</div>

<div class="imgcap">
<img src="/assets/pano/results/paloAlto.png">
<div class="thecap" style="text-align:justify">Palo Alto with RANSAC threshold 10, which has some bugs when blending but slightly better than the one below. <a href="http://hli2020.github.io/assets/pano/pano_view/paloAlto.html">360-degree view</a>.</div>
</div>

<div class="imgcap">
<img src="/assets/pano/results/paloAlto_b_lowThres.png">
<div class="thecap" style="text-align:justify">Palo Alto with low RANSAC threshold (from 10 to 5). We can see this parameter plays an important role in generating good results with blending. <a href="http://hli2020.github.io/assets/pano/pano_view/paloAlto_b_lowThres.html">360-degree view</a>.</div>
</div>

<div class="imgcap">
<img src="/assets/pano/results/piazza.png">
<div class="thecap" style="text-align:justify">Piazza. The panorama is not properly aligned, :(, which could result from a mismatch in focal length. Also I tried to tune the blendRadius parameter, but obtained similar result. <a href="http://hli2020.github.io/assets/pano/pano_view/piazza.html">360-degree view</a>.</div>
</div>

<div class="imgcap">
<img src="/assets/pano/results/piazza_b.png">
<div class="thecap" style="text-align:justify">Piazza with bundle adjustment. The odd thing is that in my experiment the bundle adjustment seems not working in this case. Maybe the focal length is not proper tuned. <a href="http://hli2020.github.io/assets/pano/pano_view/piazza_b.html">360-degree view</a>.</div>


</div>

Also there comes a bug that I haven't fixed in  the ```MSLobby.jpg``` case.
The code fails when updating the match quality for its neighbor images (line 285-293, GlobalAlign.cpp), which I haven't figured out the reason.




